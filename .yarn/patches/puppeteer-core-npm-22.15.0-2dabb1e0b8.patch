diff --git a/lib/cjs/puppeteer/cdp/ExecutionContext.d.ts b/lib/cjs/puppeteer/cdp/ExecutionContext.d.ts
index b12f4966b88abe8c9164d0dda8f66806e2fa6ce0..4223d954198285f00c51bb3a696037621d38d214 100644
--- a/lib/cjs/puppeteer/cdp/ExecutionContext.d.ts
+++ b/lib/cjs/puppeteer/cdp/ExecutionContext.d.ts
@@ -22,6 +22,7 @@ export declare class ExecutionContext extends EventEmitter<{
     bindingcalled: Protocol.Runtime.BindingCalledEvent;
 }> implements Disposable {
     #private;
+    _frameId: any;
     constructor(client: CDPSession, contextPayload: Protocol.Runtime.ExecutionContextDescription, world: IsolatedWorld);
     get id(): number;
     get puppeteerUtil(): Promise<JSHandle<PuppeteerUtil>>;
@@ -116,6 +117,8 @@ export declare class ExecutionContext extends EventEmitter<{
      * {@link ElementHandle | element handle}.
      */
     evaluateHandle<Params extends unknown[], Func extends EvaluateFunc<Params> = EvaluateFunc<Params>>(pageFunction: Func | string, ...args: Params): Promise<HandleFor<Awaited<ReturnType<Func>>>>;
+    clear(newId: any): void;
+    acquireContextId(): Promise<void>;
     [disposeSymbol](): void;
 }
 //# sourceMappingURL=ExecutionContext.d.ts.map
\ No newline at end of file
diff --git a/lib/cjs/puppeteer/cdp/ExecutionContext.js b/lib/cjs/puppeteer/cdp/ExecutionContext.js
index d37c2c89e795f2680c2e9bb9140ee230ce78d289..f6551f6ed60298c46acc6ff0b187f59eac539359 100644
--- a/lib/cjs/puppeteer/cdp/ExecutionContext.js
+++ b/lib/cjs/puppeteer/cdp/ExecutionContext.js
@@ -18,8 +18,7 @@ var __addDisposableResource = (this && this.__addDisposableResource) || function
         }
         if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
         env.stack.push({ value: value, dispose: dispose, async: async });
-    }
-    else if (async) {
+    } else if (async) {
         env.stack.push({ async: true });
     }
     return value;
@@ -83,6 +82,7 @@ class ExecutionContext extends EventEmitter_js_1.EventEmitter {
     #id;
     #name;
     #disposables = new disposable_js_1.DisposableStack();
+    _frameId;
     constructor(client, contextPayload, world) {
         super();
         this.#client = client;
@@ -91,13 +91,22 @@ class ExecutionContext extends EventEmitter_js_1.EventEmitter {
         if (contextPayload.name) {
             this.#name = contextPayload.name;
         }
+        // rebrowser-patches: keep frameId to use later
+        if (contextPayload.auxData?.frameId) {
+            this._frameId = contextPayload.auxData?.frameId;
+        }
         const clientEmitter = this.#disposables.use(new EventEmitter_js_1.EventEmitter(this.#client));
         clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));
-        clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
-            if (event.executionContextId === this.#id) {
+        if (!process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+            clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
+                if (event.executionContextId === this.#id) {
+                    this[disposable_js_1.disposeSymbol]();
+                }
+            });
+            clientEmitter.on('Runtime.executionContextsCleared', async () => {
                 this[disposable_js_1.disposeSymbol]();
-            }
-        });
+            });
+        }
         clientEmitter.on('Runtime.executionContextsCleared', async () => {
             this[disposable_js_1.disposeSymbol]();
         });
@@ -324,7 +333,72 @@ class ExecutionContext extends EventEmitter_js_1.EventEmitter {
     async evaluateHandle(pageFunction, ...args) {
         return await this.#evaluate(false, pageFunction, ...args);
     }
+
+    // rebrowser-patches: alternative to dispose
+    clear(newId) {
+        this.#id = newId;
+        this.#bindings = new Map();
+        this.#bindingsInstalled = false;
+        this.#puppeteerUtil = undefined;
+    }
+    // rebrowser-patches: get context id if it's missing
+    async acquireContextId() {
+        if (this.#id > 0) {
+            return;
+        }
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] id = ${this.#id}, name = ${this.#name}, fixMode = ${process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']}`);
+        let contextId;
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === 'alwaysIsolated') {
+            if (this.#id === -3) {
+                throw new Error('[rebrowser-patches] web workers are not supported with REBROWSER_PATCHES_RUNTIME_FIX_MODE = alwaysIsolated');
+            }
+            const sendRes = await this.#client
+                .send('Page.createIsolatedWorld', {
+                frameId: this._frameId,
+                worldName: this.#name,
+                grantUniveralAccess: true,
+            });
+            contextId = sendRes.executionContextId;
+        } else if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === 'enableDisable') {
+            const executionContextCreatedHandler = ({ context }) => {
+                process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][executionContextCreated] this.#id = ${this.#id}, name = ${this.#name}, contextId = ${contextId}, event.context.id = ${context.id}`);
+                if (contextId > 0) {
+                    // already acquired the id
+                    return;
+                }
+                if (this.#id === -1) {
+                    // main world
+                    if (context.auxData && context.auxData['isDefault']) {
+                        contextId = context.id;
+                    }
+                } else if (this.#id === -2) {
+                    // utility world
+                    if (this.#name === context.name) {
+                        contextId = context.id;
+                    }
+                } else if (this.#id === -3) {
+                    // web worker
+                    contextId = context.id;
+                }
+            };
+            this.#client.on('Runtime.executionContextCreated', executionContextCreatedHandler);
+            await this.#client.send('Runtime.enable');
+            await this.#client.send('Runtime.disable');
+            this.#client.off('Runtime.executionContextCreated', executionContextCreatedHandler);
+        }
+        if (!contextId) {
+            throw new Error('[rebrowser-patches] acquireContextId failed');
+        }
+        this.#id = contextId;
+    }
+
     async #evaluate(returnByValue, pageFunction, ...args) {
+        // rebrowser-patches: context id is missing, acquire it and try again
+        if (this.#id < 0) {
+            await this.acquireContextId();
+            // @ts-ignore
+            return this.#evaluate(returnByValue, pageFunction, ...args);
+        }
         const sourceUrlComment = (0, util_js_1.getSourceUrlComment)((0, util_js_1.getSourcePuppeteerURLIfAvailable)(pageFunction)?.toString() ??
             util_js_1.PuppeteerURL.INTERNAL_URL);
         if ((0, util_js_1.isString)(pageFunction)) {
diff --git a/lib/cjs/puppeteer/cdp/FrameManager.js b/lib/cjs/puppeteer/cdp/FrameManager.js
index a41bdcbdb09ab0f50fce4d81e407079513a2b188..e3aa29dc57ce22e133707b85f49754a1f7c98bcd 100644
--- a/lib/cjs/puppeteer/cdp/FrameManager.js
+++ b/lib/cjs/puppeteer/cdp/FrameManager.js
@@ -150,6 +150,10 @@ class FrameManager extends EventEmitter_js_1.EventEmitter {
             this.#onFrameStoppedLoading(event.frameId);
         });
         session.on('Runtime.executionContextCreated', async (event) => {
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+                // rebrowser-patches: ignore default logic
+                return;
+            }
             await this.#frameTreeHandled?.valueOrThrow();
             this.#onExecutionContextCreated(event.context, session);
         });
@@ -174,9 +178,16 @@ class FrameManager extends EventEmitter_js_1.EventEmitter {
                     this.#frameTreeHandled?.resolve();
                 }),
                 client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
-                client.send('Runtime.enable').then(() => {
-                    return this.#createIsolatedWorld(client, util_js_1.UTILITY_WORLD_NAME);
-                }),
+                (() => {
+                    // rebrowser-patches: skip Runtime.enable
+                    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+                        process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][FrameManager] initialize');
+                        return this.#createIsolatedWorld(client, util_js_1.UTILITY_WORLD_NAME);
+                    }
+                    return client.send('Runtime.enable').then(() => {
+                        return this.#createIsolatedWorld(client, util_js_1.UTILITY_WORLD_NAME);
+                    });
+                })(),
                 ...(frame
                     ? Array.from(this.#scriptsToEvaluateOnNewDocument.values())
                     : []).map(script => {
@@ -186,6 +197,26 @@ class FrameManager extends EventEmitter_js_1.EventEmitter {
                     return frame?.addExposedFunctionBinding(binding);
                 }),
             ]);
+            // rebrowser-patches: manually create main world context
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+                this.frames()
+                    .filter(frame => {
+                    return frame.client === client;
+                }).map(frame => {
+                    const world = frame.worlds[IsolatedWorlds_js_1.MAIN_WORLD];
+                    const contextPayload = {
+                        id: -1,
+                        name: '',
+                        auxData: {
+                            frameId: frame._id,
+                        }
+                    };
+                    const context = new ExecutionContext_js_1.ExecutionContext(frame.client, 
+                    // @ts-ignore
+                    contextPayload, world);
+                    world.setContext(context);
+                });
+            }
         }
         catch (error) {
             this.#frameTreeHandled?.resolve();
@@ -353,6 +384,23 @@ class FrameManager extends EventEmitter_js_1.EventEmitter {
             }
             this._frameTree.addFrame(frame);
         }
+        // rebrowser-patches: we cannot fully dispose contexts as they won't be recreated as we don't have Runtime events,
+        // instead, just mark it all empty
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches] onFrameNavigated, navigationType = ${navigationType}, id = ${framePayload.id}, url = ${framePayload.url}`);
+            for (const worldSymbol of [IsolatedWorlds_js_1.MAIN_WORLD, IsolatedWorlds_js_1.PUPPETEER_WORLD]) {
+                // @ts-ignore
+                if (frame.worlds[worldSymbol].context) {
+                    // @ts-ignore
+                    const frameOrWorker = frame.worlds[worldSymbol].environment;
+                    if ('clearDocumentHandle' in frameOrWorker) {
+                        frameOrWorker.clearDocumentHandle();
+                    }
+                    // @ts-ignore
+                    frame.worlds[worldSymbol].context?.clear(worldSymbol === IsolatedWorlds_js_1.MAIN_WORLD ? -1 : -2);
+                }
+            }
+        }
         frame = await this._frameTree.waitForFrame(frameId);
         frame._navigated(framePayload);
         this.emit(FrameManagerEvents_js_1.FrameManagerEvent.FrameNavigated, frame);
@@ -380,7 +428,21 @@ class FrameManager extends EventEmitter_js_1.EventEmitter {
                 worldName: name,
                 grantUniveralAccess: true,
             })
-                .catch(util_js_1.debugError);
+                .catch(util_js_1.debugError)
+                .then(({ executionContextId }) => {
+                // rebrowser-patches: save created context id
+                if (!process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+                    return;
+                }
+                // @ts-ignore
+                this.#onExecutionContextCreated({
+                    id: executionContextId,
+                    name,
+                    auxData: {
+                        frameId: frame._id,
+                    }
+                }, frame.client);
+            });
         }));
         this.#isolatedWorlds.add(key);
     }
diff --git a/lib/cjs/puppeteer/cdp/IsolatedWorld.js b/lib/cjs/puppeteer/cdp/IsolatedWorld.js
index 713b924281a78906505c0d1c2ce9c43e7e0312d4..f3b25437dc7655d2fde4967efd98fc65e5e8e6df 100644
--- a/lib/cjs/puppeteer/cdp/IsolatedWorld.js
+++ b/lib/cjs/puppeteer/cdp/IsolatedWorld.js
@@ -106,6 +106,8 @@ class IsolatedWorld extends Realm_js_1.Realm {
         if (!context) {
             context = await this.#waitForExecutionContext();
         }
+        // rebrowser-patches: make sure id is acquired
+        await context.acquireContextId();
         const { object } = await this.client.send('DOM.resolveNode', {
             backendNodeId: backendNodeId,
             executionContextId: context.id,
diff --git a/lib/cjs/puppeteer/cdp/WebWorker.js b/lib/cjs/puppeteer/cdp/WebWorker.js
index 6f7ae4ba26edda039b46898744cb053d1a9bde39..84a1f8976de78790e41f708df1c7b6c5d0d01cef 100644
--- a/lib/cjs/puppeteer/cdp/WebWorker.js
+++ b/lib/cjs/puppeteer/cdp/WebWorker.js
@@ -24,6 +24,10 @@ class CdpWebWorker extends WebWorker_js_1.WebWorker {
         this.#targetType = targetType;
         this.#world = new IsolatedWorld_js_1.IsolatedWorld(this, new TimeoutSettings_js_1.TimeoutSettings());
         this.#client.once('Runtime.executionContextCreated', async (event) => {
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+                // rebrowser-patches: ignore default logic
+                return;
+            }
             this.#world.setContext(new ExecutionContext_js_1.ExecutionContext(client, event.context, this.#world));
         });
         this.#world.emitter.on('consoleapicalled', async (event) => {
@@ -40,8 +44,19 @@ class CdpWebWorker extends WebWorker_js_1.WebWorker {
         this.#client.once(CDPSession_js_1.CDPSessionEvent.Disconnected, () => {
             this.#world.dispose();
         });
-        // This might fail if the target is closed before we receive all execution contexts.
-        this.#client.send('Runtime.enable').catch(util_js_1.debugError);
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+            // @ts-ignore
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][WebWorker] initialize', targetType, targetId, client._target(), client._target()._getTargetInfo());
+            // rebrowser-patches: manually create context
+            const contextPayload = {
+                id: -3,
+            };
+            // @ts-ignore
+            this.#world.setContext(new ExecutionContext_js_1.ExecutionContext(client, contextPayload, this.#world));
+        } else {
+            // This might fail if the target is closed before we receive all execution contexts.
+            this.#client.send('Runtime.enable').catch(util_js_1.debugError);
+        }
     }
     mainRealm() {
         return this.#world;
diff --git a/lib/cjs/puppeteer/injected/injected.d.ts b/lib/cjs/puppeteer/injected/injected.d.ts
index f672ea1a30d54a417265dcc0ff9dce9c6ec37e82..7735d2aedbfc926fb7e5f1f2c8b486c4cf4b0cc2 100644
--- a/lib/cjs/puppeteer/injected/injected.d.ts
+++ b/lib/cjs/puppeteer/injected/injected.d.ts
@@ -31,7 +31,7 @@ declare const PuppeteerUtil: Readonly<{
     pierceQuerySelector: (root: Node, selector: string) => Element | null;
     pierceQuerySelectorAll: (element: Node, selector: string) => Element[];
     customQuerySelectors: {
-        "__#55474@#selectors": Map<string, CustomQuerySelectors.CustomQuerySelector>;
+        "__#55515@#selectors": Map<string, CustomQuerySelectors.CustomQuerySelector>;
         register(name: string, handler: import("../index.js").CustomQueryHandler): void;
         unregister(name: string): void;
         get(name: string): CustomQuerySelectors.CustomQuerySelector | undefined;
diff --git a/lib/cjs/puppeteer/util/Mutex.d.ts b/lib/cjs/puppeteer/util/Mutex.d.ts
index 3322a578c57f2a2ed6afff44233b6e0d06fe6b51..b9f8aa5e2a0ca5ad7c26046ab84f38e99e3ba4fe 100644
--- a/lib/cjs/puppeteer/util/Mutex.d.ts
+++ b/lib/cjs/puppeteer/util/Mutex.d.ts
@@ -6,8 +6,8 @@ export declare class Mutex {
     #private;
     static Guard: {
         new (mutex: Mutex, onRelease?: () => void): {
-            "__#55462@#mutex": Mutex;
-            "__#55462@#onRelease"?: (() => void) | undefined;
+            "__#55503@#mutex": Mutex;
+            "__#55503@#onRelease"?: (() => void) | undefined;
             [Symbol.dispose](): void;
         };
     };
diff --git a/lib/esm/puppeteer/cdp/ExecutionContext.d.ts b/lib/esm/puppeteer/cdp/ExecutionContext.d.ts
index b12f4966b88abe8c9164d0dda8f66806e2fa6ce0..4223d954198285f00c51bb3a696037621d38d214 100644
--- a/lib/esm/puppeteer/cdp/ExecutionContext.d.ts
+++ b/lib/esm/puppeteer/cdp/ExecutionContext.d.ts
@@ -22,6 +22,7 @@ export declare class ExecutionContext extends EventEmitter<{
     bindingcalled: Protocol.Runtime.BindingCalledEvent;
 }> implements Disposable {
     #private;
+    _frameId: any;
     constructor(client: CDPSession, contextPayload: Protocol.Runtime.ExecutionContextDescription, world: IsolatedWorld);
     get id(): number;
     get puppeteerUtil(): Promise<JSHandle<PuppeteerUtil>>;
@@ -116,6 +117,8 @@ export declare class ExecutionContext extends EventEmitter<{
      * {@link ElementHandle | element handle}.
      */
     evaluateHandle<Params extends unknown[], Func extends EvaluateFunc<Params> = EvaluateFunc<Params>>(pageFunction: Func | string, ...args: Params): Promise<HandleFor<Awaited<ReturnType<Func>>>>;
+    clear(newId: any): void;
+    acquireContextId(): Promise<void>;
     [disposeSymbol](): void;
 }
 //# sourceMappingURL=ExecutionContext.d.ts.map
\ No newline at end of file
diff --git a/lib/esm/puppeteer/cdp/ExecutionContext.js b/lib/esm/puppeteer/cdp/ExecutionContext.js
index 295660d50f4ac50aaf221f062adf6817c16f5bbc..33af2189440fb33f88928aa598878b23b5a713fe 100644
--- a/lib/esm/puppeteer/cdp/ExecutionContext.js
+++ b/lib/esm/puppeteer/cdp/ExecutionContext.js
@@ -80,6 +80,7 @@ export class ExecutionContext extends EventEmitter {
     #id;
     #name;
     #disposables = new DisposableStack();
+    _frameId;
     constructor(client, contextPayload, world) {
         super();
         this.#client = client;
@@ -88,16 +89,22 @@ export class ExecutionContext extends EventEmitter {
         if (contextPayload.name) {
             this.#name = contextPayload.name;
         }
+        // rebrowser-patches: keep frameId to use later
+        if (contextPayload.auxData?.frameId) {
+            this._frameId = contextPayload.auxData?.frameId;
+        }
         const clientEmitter = this.#disposables.use(new EventEmitter(this.#client));
         clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));
-        clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
-            if (event.executionContextId === this.#id) {
+        if (!process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+            clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
+                if (event.executionContextId === this.#id) {
+                    this[disposeSymbol]();
+                }
+            });
+            clientEmitter.on('Runtime.executionContextsCleared', async () => {
                 this[disposeSymbol]();
-            }
-        });
-        clientEmitter.on('Runtime.executionContextsCleared', async () => {
-            this[disposeSymbol]();
-        });
+            });
+        }
         clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));
         clientEmitter.on(CDPSessionEvent.Disconnected, () => {
             this[disposeSymbol]();
@@ -321,7 +328,72 @@ export class ExecutionContext extends EventEmitter {
     async evaluateHandle(pageFunction, ...args) {
         return await this.#evaluate(false, pageFunction, ...args);
     }
+
+    // rebrowser-patches: alternative to dispose
+    clear(newId) {
+        this.#id = newId;
+        this.#bindings = new Map();
+        this.#bindingsInstalled = false;
+        this.#puppeteerUtil = undefined;
+    }
+    // rebrowser-patches: get context id if it's missing
+    async acquireContextId() {
+        if (this.#id > 0) {
+            return;
+        }
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] id = ${this.#id}, name = ${this.#name}, fixMode = ${process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']}`);
+        let contextId;
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === 'alwaysIsolated') {
+            if (this.#id === -3) {
+                throw new Error('[rebrowser-patches] web workers are not supported with REBROWSER_PATCHES_RUNTIME_FIX_MODE = alwaysIsolated');
+            }
+            const sendRes = await this.#client
+                .send('Page.createIsolatedWorld', {
+                frameId: this._frameId,
+                worldName: this.#name,
+                grantUniveralAccess: true,
+            });
+            contextId = sendRes.executionContextId;
+        } else if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === 'enableDisable') {
+            const executionContextCreatedHandler = ({ context }) => {
+                process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][executionContextCreated] this.#id = ${this.#id}, name = ${this.#name}, contextId = ${contextId}, event.context.id = ${context.id}`);
+                if (contextId > 0) {
+                    // already acquired the id
+                    return;
+                }
+                if (this.#id === -1) {
+                    // main world
+                    if (context.auxData && context.auxData['isDefault']) {
+                        contextId = context.id;
+                    }
+                } else if (this.#id === -2) {
+                    // utility world
+                    if (this.#name === context.name) {
+                        contextId = context.id;
+                    }
+                } else if (this.#id === -3) {
+                    // web worker
+                    contextId = context.id;
+                }
+            };
+            this.#client.on('Runtime.executionContextCreated', executionContextCreatedHandler);
+            await this.#client.send('Runtime.enable');
+            await this.#client.send('Runtime.disable');
+            this.#client.off('Runtime.executionContextCreated', executionContextCreatedHandler);
+        }
+        if (!contextId) {
+            throw new Error('[rebrowser-patches] acquireContextId failed');
+        }
+        this.#id = contextId;
+    }
+
     async #evaluate(returnByValue, pageFunction, ...args) {
+        // rebrowser-patches: context id is missing, acquire it and try again
+        if (this.#id < 0) {
+            await this.acquireContextId();
+            // @ts-ignore
+            return this.#evaluate(returnByValue, pageFunction, ...args);
+        }
         const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ??
             PuppeteerURL.INTERNAL_URL);
         if (isString(pageFunction)) {
diff --git a/lib/esm/puppeteer/cdp/FrameManager.js b/lib/esm/puppeteer/cdp/FrameManager.js
index 241c5f95bb60a858370974d97fbdba5cccc4aa41..035bb4a11c52611cdce88d5be56c3110d24fe2e8 100644
--- a/lib/esm/puppeteer/cdp/FrameManager.js
+++ b/lib/esm/puppeteer/cdp/FrameManager.js
@@ -147,6 +147,10 @@ export class FrameManager extends EventEmitter {
             this.#onFrameStoppedLoading(event.frameId);
         });
         session.on('Runtime.executionContextCreated', async (event) => {
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+                // rebrowser-patches: ignore default logic
+                return;
+            }
             await this.#frameTreeHandled?.valueOrThrow();
             this.#onExecutionContextCreated(event.context, session);
         });
@@ -171,9 +175,16 @@ export class FrameManager extends EventEmitter {
                     this.#frameTreeHandled?.resolve();
                 }),
                 client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
-                client.send('Runtime.enable').then(() => {
-                    return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
-                }),
+                (() => {
+                    // rebrowser-patches: skip Runtime.enable
+                    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+                        process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][FrameManager] initialize');
+                        return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
+                    }
+                    return client.send('Runtime.enable').then(() => {
+                        return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
+                    });
+                })(),
                 ...(frame
                     ? Array.from(this.#scriptsToEvaluateOnNewDocument.values())
                     : []).map(script => {
@@ -183,6 +194,26 @@ export class FrameManager extends EventEmitter {
                     return frame?.addExposedFunctionBinding(binding);
                 }),
             ]);
+            // rebrowser-patches: manually create main world context
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+                this.frames()
+                    .filter(frame => {
+                    return frame.client === client;
+                }).map(frame => {
+                    const world = frame.worlds[MAIN_WORLD];
+                    const contextPayload = {
+                        id: -1,
+                        name: '',
+                        auxData: {
+                            frameId: frame._id,
+                        }
+                    };
+                    const context = new ExecutionContext(frame.client, 
+                    // @ts-ignore
+                    contextPayload, world);
+                    world.setContext(context);
+                });
+            }
         }
         catch (error) {
             this.#frameTreeHandled?.resolve();
@@ -350,6 +381,23 @@ export class FrameManager extends EventEmitter {
             }
             this._frameTree.addFrame(frame);
         }
+        // rebrowser-patches: we cannot fully dispose contexts as they won't be recreated as we don't have Runtime events,
+        // instead, just mark it all empty
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches] onFrameNavigated, navigationType = ${navigationType}, id = ${framePayload.id}, url = ${framePayload.url}`);
+            for (const worldSymbol of [MAIN_WORLD, PUPPETEER_WORLD]) {
+                // @ts-ignore
+                if (frame.worlds[worldSymbol].context) {
+                    // @ts-ignore
+                    const frameOrWorker = frame.worlds[worldSymbol].environment;
+                    if ('clearDocumentHandle' in frameOrWorker) {
+                        frameOrWorker.clearDocumentHandle();
+                    }
+                    // @ts-ignore
+                    frame.worlds[worldSymbol].context?.clear(worldSymbol === MAIN_WORLD ? -1 : -2);
+                }
+            }
+        }
         frame = await this._frameTree.waitForFrame(frameId);
         frame._navigated(framePayload);
         this.emit(FrameManagerEvent.FrameNavigated, frame);
@@ -377,7 +425,21 @@ export class FrameManager extends EventEmitter {
                 worldName: name,
                 grantUniveralAccess: true,
             })
-                .catch(debugError);
+                .catch(debugError)
+                .then(({ executionContextId }) => {
+                // rebrowser-patches: save created context id
+                if (!process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+                    return;
+                }
+                // @ts-ignore
+                this.#onExecutionContextCreated({
+                    id: executionContextId,
+                    name,
+                    auxData: {
+                        frameId: frame._id,
+                    }
+                }, frame.client);
+            });
         }));
         this.#isolatedWorlds.add(key);
     }
diff --git a/lib/esm/puppeteer/cdp/IsolatedWorld.js b/lib/esm/puppeteer/cdp/IsolatedWorld.js
index c1c89e838fe941230ef9ef5b652147de3e431788..ac1a31fc4e044c5fe701d7af6e1b3a96ee57cb6d 100644
--- a/lib/esm/puppeteer/cdp/IsolatedWorld.js
+++ b/lib/esm/puppeteer/cdp/IsolatedWorld.js
@@ -103,6 +103,8 @@ export class IsolatedWorld extends Realm {
         if (!context) {
             context = await this.#waitForExecutionContext();
         }
+        // rebrowser-patches: make sure id is acquired
+        await context.acquireContextId();
         const { object } = await this.client.send('DOM.resolveNode', {
             backendNodeId: backendNodeId,
             executionContextId: context.id,
diff --git a/lib/esm/puppeteer/cdp/WebWorker.js b/lib/esm/puppeteer/cdp/WebWorker.js
index 8837f17e443081f591db64473d7420e94b6abfa8..6851b5ee74f8e3e1f828051f6813280e0fe91e55 100644
--- a/lib/esm/puppeteer/cdp/WebWorker.js
+++ b/lib/esm/puppeteer/cdp/WebWorker.js
@@ -21,6 +21,10 @@ export class CdpWebWorker extends WebWorker {
         this.#targetType = targetType;
         this.#world = new IsolatedWorld(this, new TimeoutSettings());
         this.#client.once('Runtime.executionContextCreated', async (event) => {
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+                // rebrowser-patches: ignore default logic
+                return;
+            }
             this.#world.setContext(new ExecutionContext(client, event.context, this.#world));
         });
         this.#world.emitter.on('consoleapicalled', async (event) => {
@@ -37,8 +41,19 @@ export class CdpWebWorker extends WebWorker {
         this.#client.once(CDPSessionEvent.Disconnected, () => {
             this.#world.dispose();
         });
-        // This might fail if the target is closed before we receive all execution contexts.
-        this.#client.send('Runtime.enable').catch(debugError);
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+            // @ts-ignore
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][WebWorker] initialize', targetType, targetId, client._target(), client._target()._getTargetInfo());
+            // rebrowser-patches: manually create context
+            const contextPayload = {
+                id: -3,
+            };
+            // @ts-ignore
+            this.#world.setContext(new ExecutionContext(client, contextPayload, this.#world));
+        } else {
+            // This might fail if the target is closed before we receive all execution contexts.
+            this.#client.send('Runtime.enable').catch(debugError);
+        }
     }
     mainRealm() {
         return this.#world;
diff --git a/src/cdp/ExecutionContext.ts b/src/cdp/ExecutionContext.ts
index 257d73f371452aca8e629c71ee093cc3f3b6635d..cb4451fb3b6a1f851304fefd7f0b95e97ffa65c3 100644
--- a/src/cdp/ExecutionContext.ts
+++ b/src/cdp/ExecutionContext.ts
@@ -79,6 +79,7 @@ export class ExecutionContext
   #world: IsolatedWorld;
   #id: number;
   #name?: string;
+  _frameId: any;
 
   readonly #disposables = new DisposableStack();
 
@@ -94,16 +95,22 @@ export class ExecutionContext
     if (contextPayload.name) {
       this.#name = contextPayload.name;
     }
+    // rebrowser-patches: keep frameId to use later
+    if (contextPayload.auxData?.frameId) {
+      this._frameId = contextPayload.auxData?.frameId;
+    }
     const clientEmitter = this.#disposables.use(new EventEmitter(this.#client));
     clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));
-    clientEmitter.on('Runtime.executionContextDestroyed', async event => {
-      if (event.executionContextId === this.#id) {
+    if (!process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+      clientEmitter.on('Runtime.executionContextDestroyed', async event => {
+        if (event.executionContextId === this.#id) {
+          this[disposeSymbol]();
+        }
+      });
+      clientEmitter.on('Runtime.executionContextsCleared', async () => {
         this[disposeSymbol]();
-      }
-    });
-    clientEmitter.on('Runtime.executionContextsCleared', async () => {
-      this[disposeSymbol]();
-    });
+      });
+    }
     clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));
     clientEmitter.on(CDPSessionEvent.Disconnected, () => {
       this[disposeSymbol]();
@@ -351,6 +358,71 @@ export class ExecutionContext
     return await this.#evaluate(false, pageFunction, ...args);
   }
 
+  // rebrowser-patches: alternative to dispose
+  clear(newId: any) {
+    this.#id = newId
+    this.#bindings = new Map()
+    this.#bindingsInstalled = false
+    this.#puppeteerUtil = undefined
+  }
+  // rebrowser-patches: get context id if it's missing
+  async acquireContextId() {
+    if (this.#id > 0) {
+      return
+    }
+    process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] id = ${this.#id}, name = ${this.#name}, fixMode = ${process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']}`)
+
+    let contextId: any
+    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === 'alwaysIsolated') {
+      if (this.#id === -3) {
+        throw new Error('[rebrowser-patches] web workers are not supported with REBROWSER_PATCHES_RUNTIME_FIX_MODE = alwaysIsolated')
+      }
+
+      const sendRes = await this.#client
+        .send('Page.createIsolatedWorld', {
+          frameId: this._frameId,
+          worldName: this.#name,
+          grantUniveralAccess: true,
+        })
+      contextId = sendRes.executionContextId
+    } else if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === 'enableDisable') {
+      const executionContextCreatedHandler = ({ context }: any) => {
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][executionContextCreated] this.#id = ${this.#id}, name = ${this.#name}, contextId = ${contextId}, event.context.id = ${context.id}`)
+
+        if (contextId > 0) {
+          // already acquired the id
+          return
+        }
+
+        if (this.#id === -1) {
+          // main world
+          if (context.auxData && context.auxData['isDefault']) {
+            contextId = context.id
+          }
+        } else if (this.#id === -2) {
+          // utility world
+          if (this.#name === context.name) {
+            contextId = context.id
+          }
+        } else if (this.#id === -3) {
+          // web worker
+          contextId = context.id
+        }
+      }
+
+      this.#client.on('Runtime.executionContextCreated', executionContextCreatedHandler)
+      await this.#client.send('Runtime.enable')
+      await this.#client.send('Runtime.disable')
+      this.#client.off('Runtime.executionContextCreated', executionContextCreatedHandler)
+    }
+
+    if (!contextId) {
+      throw new Error('[rebrowser-patches] acquireContextId failed')
+    }
+
+    this.#id = contextId
+  }
+
   async #evaluate<
     Params extends unknown[],
     Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,
diff --git a/src/cdp/FrameManager.ts b/src/cdp/FrameManager.ts
index d5a7a6a20d51c6cc805c3b98710d7cb9f1350e52..65ecbf05763995f527090d98ecb8f3e12b6bb52a 100644
--- a/src/cdp/FrameManager.ts
+++ b/src/cdp/FrameManager.ts
@@ -212,9 +212,17 @@ export class FrameManager extends EventEmitter<FrameManagerEvents> {
           this.#frameTreeHandled?.resolve();
         }),
         client.send('Page.setLifecycleEventsEnabled', {enabled: true}),
-        client.send('Runtime.enable').then(() => {
-          return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
-        }),
+        (() => {
+          // rebrowser-patches: skip Runtime.enable
+          if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][FrameManager] initialize')
+            return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME)
+          }
+
+          return client.send('Runtime.enable').then(() => {
+            return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
+          })
+        })(),
         ...(frame
           ? Array.from(this.#scriptsToEvaluateOnNewDocument.values())
           : []
@@ -225,6 +233,30 @@ export class FrameManager extends EventEmitter<FrameManagerEvents> {
           return frame?.addExposedFunctionBinding(binding);
         }),
       ]);
+
+      // rebrowser-patches: manually create main world context
+      if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+        this.frames()
+          .filter(frame => {
+            return frame.client === client;
+          }).map(frame => {
+          const world = frame.worlds[MAIN_WORLD]
+          const contextPayload = {
+            id: -1,
+            name: '',
+            auxData: {
+              frameId: frame._id,
+            }
+          }
+          const context = new ExecutionContext(
+            frame.client,
+            // @ts-ignore
+            contextPayload,
+            world
+          );
+          world.setContext(context);
+        })
+      }
     } catch (error) {
       this.#frameTreeHandled?.resolve();
       // The target might have been closed before the initialization finished.
@@ -450,6 +482,24 @@ export class FrameManager extends EventEmitter<FrameManagerEvents> {
       this._frameTree.addFrame(frame);
     }
 
+    // rebrowser-patches: we cannot fully dispose contexts as they won't be recreated as we don't have Runtime events,
+    // instead, just mark it all empty
+    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches] onFrameNavigated, navigationType = ${navigationType}, id = ${framePayload.id}, url = ${framePayload.url}`)
+      for (const worldSymbol of [MAIN_WORLD, PUPPETEER_WORLD]) {
+        // @ts-ignore
+        if (frame.worlds[worldSymbol].context) {
+          // @ts-ignore
+          const frameOrWorker = frame.worlds[worldSymbol].environment
+          if ('clearDocumentHandle' in frameOrWorker) {
+            frameOrWorker.clearDocumentHandle();
+          }
+          // @ts-ignore
+          frame.worlds[worldSymbol].context?.clear(worldSymbol === MAIN_WORLD ? -1 : -2)
+        }
+      }
+    }
+
     frame = await this._frameTree.waitForFrame(frameId);
     frame._navigated(framePayload);
     this.emit(FrameManagerEvent.FrameNavigated, frame);
@@ -482,7 +532,21 @@ export class FrameManager extends EventEmitter<FrameManagerEvents> {
               worldName: name,
               grantUniveralAccess: true,
             })
-            .catch(debugError);
+            .catch(debugError)
+            .then(({ executionContextId }: any) => {
+              // rebrowser-patches: save created context id
+              if (!process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+                return
+              }
+              // @ts-ignore
+              this.#onExecutionContextCreated({
+                id: executionContextId,
+                name,
+                auxData: {
+                  frameId: frame._id,
+                }
+              }, frame.client)
+            });
         })
     );
 
diff --git a/src/cdp/IsolatedWorld.ts b/src/cdp/IsolatedWorld.ts
index 0f4965a5f5f9d31bc90a749afbfaaf1950266da1..89b5b5984edc0ff71dd35436993b3ab87019ff48 100644
--- a/src/cdp/IsolatedWorld.ts
+++ b/src/cdp/IsolatedWorld.ts
@@ -204,6 +204,8 @@ export class IsolatedWorld extends Realm {
     if (!context) {
       context = await this.#waitForExecutionContext();
     }
+    // rebrowser-patches: make sure id is acquired
+    await context.acquireContextId()
     const {object} = await this.client.send('DOM.resolveNode', {
       backendNodeId: backendNodeId,
       executionContextId: context.id,
diff --git a/src/cdp/WebWorker.ts b/src/cdp/WebWorker.ts
index e538a63e8525922d0d2b1c209a6e17da8574aaa4..918b8223bb8406126f4bc0dfbb0e822382a000a1 100644
--- a/src/cdp/WebWorker.ts
+++ b/src/cdp/WebWorker.ts
@@ -56,6 +56,10 @@ export class CdpWebWorker extends WebWorker {
     this.#world = new IsolatedWorld(this, new TimeoutSettings());
 
     this.#client.once('Runtime.executionContextCreated', async event => {
+      if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+        // rebrowser-patches: ignore default logic
+        return
+      }
       this.#world.setContext(
         new ExecutionContext(client, event.context, this.#world)
       );
@@ -78,8 +82,20 @@ export class CdpWebWorker extends WebWorker {
       this.#world.dispose();
     });
 
-    // This might fail if the target is closed before we receive all execution contexts.
-    this.#client.send('Runtime.enable').catch(debugError);
+    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE']) {
+      // @ts-ignore
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][WebWorker] initialize', targetType, targetId, client._target(), client._target()._getTargetInfo())
+
+      // rebrowser-patches: manually create context
+      const contextPayload = {
+        id: -3,
+      }
+      // @ts-ignore
+      this.#world.setContext(new ExecutionContext(client, contextPayload, this.#world));
+    } else {
+      // This might fail if the target is closed before we receive all execution contexts.
+      this.#client.send('Runtime.enable').catch(debugError);
+    }
   }
 
   mainRealm(): Realm {
